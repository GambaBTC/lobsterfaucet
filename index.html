<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lobster Invaders - Solana Faucet</title>
    <script src="https://js.hcaptcha.com/1/api.js" async defer></script>
    <style>
        /* Same styles as before, omitted for brevity */
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Same HTML structure as before -->
    </div>

    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        const faucetScreen = document.getElementById('faucet-screen');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const victoryScreen = document.getElementById('victory-screen');
        const solAddressInput = document.getElementById('sol-address-input');
        const submitAddressButton = document.getElementById('submit-address-button');
        const faucetError = document.getElementById('faucet-error');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');
        const victoryRestartButton = document.getElementById('victory-restart-button');
        const scoreDisplay = document.getElementById('score-display');
        const waveDisplay = document.getElementById('wave-display');
        const livesDisplay = document.getElementById('lives-display');
        const finalScoreDisplay = document.getElementById('final-score');
        const victoryScoreDisplay = document.getElementById('victory-score');
        const rewardMessage = document.getElementById('reward-message');
        const victoryRewardMessage = document.getElementById('victory-reward');
        const pauseButton = document.getElementById('pause-button');
        const mobileControls = document.getElementById('mobile-controls');
        const leftButton = document.getElementById('left-button');
        const rightButton = document.getElementById('right-button');
        const fireButton = document.getElementById('fire-button');
        
        canvas.width = 800;
        canvas.height = 600;
        
        let animationId;
        let gameActive = false;
        let gamePaused = false;
        let score = 0;
        let lives = 3;
        let wave = 1;
        let lastTime = 0;
        const FINAL_WAVE = 10;
        let playerAddress = '';
        let gameToken = '';
        let sessionId = '';
        let lastMoveTime = 0;
        let moveCount = 0;
        let lastUpdateTime = 0;
        
        let player;
        let bullets = [];
        let enemies = [];
        let enemyBullets = [];
        let explosions = [];
        
        const keys = { ArrowLeft: false, ArrowRight: false, Space: false };
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

        class Player {
            constructor() {
                this.width = 60;
                this.height = 30;
                this.x = canvas.width / 2 - this.width / 2;
                this.y = canvas.height - 60;
                this.speed = 6;
                this.color = '#4a90e2';
                this.cooldown = 0;
                this.maxCooldown = 35;
                this.invulnerable = false;
                this.invulnerableTime = 0;
                this.invulnerableDuration = 60;
            }
            
            draw() { /* Same as before */ }
            
            update() {
                const now = Date.now();
                if (keys.ArrowLeft && this.x > 0) {
                    this.x -= this.speed;
                    lastMoveTime = now;
                    moveCount++;
                }
                if (keys.ArrowRight && this.x < canvas.width - this.width) {
                    this.x += this.speed;
                    lastMoveTime = now;
                    moveCount++;
                }
                if (this.cooldown > 0) this.cooldown--;
                if (keys.Space && this.cooldown === 0) {
                    this.shoot();
                    this.cooldown = this.maxCooldown;
                }
                if (this.invulnerable) {
                    this.invulnerableTime++;
                    if (this.invulnerableTime >= this.invulnerableDuration) {
                        this.invulnerable = false;
                        this.invulnerableTime = 0;
                    }
                }
            }
            
            shoot() {
                bullets.push(new Bullet(this.x + this.width / 2 - 2, this.y - 25, 4, 10, '#ffffff', 8));
                updateServer('shoot');
            }

            hit() {
                if (!this.invulnerable) {
                    lives--;
                    livesDisplay.textContent = `Lives: ${lives}`;
                    this.invulnerable = true;
                    this.invulnerableTime = 0;
                    updateServer('hit');
                    if (lives <= 0) gameOver();
                }
            }
        }
        
        class Bullet { /* Same as before */ }
        class EnemyBullet { /* Same as before */ }
        class Enemy {
            constructor(x, y, size, color, health, points, speed, shootRate) {
                this.x = x;
                this.y = y;
                this.width = size;
                this.height = size;
                this.color = color;
                this.health = health;
                this.points = points;
                this.speed = speed;
                this.direction = Math.random() > 0.5 ? 1 : -1;
                this.shootRate = shootRate;
                this.animFrame = 0;
                this.animDelay = 10;
                this.animCounter = 0;
                this.sinking = false;
                this.sinkSpeed = 2;
                this.rotation = 0;
                this.maxRotation = Math.PI / 6;
            }
            
            draw() { /* Same as before */ }
            
            update() { /* Same as before */ }
            
            shoot() {
                enemyBullets.push(new EnemyBullet(this.x + this.width / 2 - 2, this.y + this.height));
            }
            
            hit() {
                this.health--;
                if (this.health <= 0) {
                    this.sinking = true;
                    score += this.points;
                    scoreDisplay.textContent = `Score: ${score}`;
                    updateServer('enemy-killed');
                    return true;
                }
                return false;
            }
        }
        class Explosion { /* Same as before */ }
        
        function createEnemies() {
            enemies = enemies.filter(enemy => !enemy.sinking);
            if (wave > FINAL_WAVE) {
                victory();
                return;
            }
            let difficultyMultiplier = wave <= 3 ? 1.0 + (wave * 0.15) : wave <= 5 ? 1.2 + ((wave - 3) * 0.15) : 1.6 + ((wave - 5) * 0.2);
            waveDisplay.textContent = `Wave: ${wave}/${FINAL_WAVE}`;
            let rows = wave <= 3 ? 4 : wave <= 5 ? 4 : Math.min(5, 4 + Math.floor((wave - 5) / 2));
            const cols = wave <= 3 ? 9 : wave <= 5 ? 8 : Math.min(10, 8 + Math.floor((wave - 5) / 2));
            const totalWidth = canvas.width * 0.85;
            const xMargin = (canvas.width - totalWidth) / 2;
            const colSpacing = totalWidth / (cols - 1);
            const yStart = 60;
            const rowSpacing = 60;
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const size = 40 - (row * 5);
                    const colors = ['#ff0000', '#ff6600', '#ff9900', '#ffcc00', '#ffee00'];
                    let health = wave <= 3 ? (row === 0 ? 1 + wave : row === 1 ? 1 + Math.floor(wave / 2) : row === 2 && wave >= 2 ? 2 : 1) :
                                 wave <= 5 ? (row === 0 ? 2 + Math.floor((wave - 3) / 2) : row === 1 ? 2 : row === 2 && wave >= 5 ? 2 : 1) :
                                 (row === 0 ? Math.min(5, 3 + Math.floor((wave - 5) / 2)) : row === 1 ? Math.min(4, 2 + Math.floor((wave - 5) / 2)) : row === 2 ? Math.min(3, 1 + Math.floor((wave - 5) / 2)) : 1 + Math.floor((wave - 8) / 2));
                    const points = 10 * (rows - row) * health * (1 + (wave * 0.1));
                    const speed = (wave <= 3 ? 0.7 + (row * 0.2) : 0.7 + (row * 0.15)) * difficultyMultiplier;
                    const shootRate = (wave <= 3 ? 0.0006 : 0.0004) * difficultyMultiplier * (1 + (row * 0.3));
                    const xPos = xMargin + (col * colSpacing) - (size / 2);
                    const yPos = yStart + (row * rowSpacing);
                    enemies.push(new Enemy(xPos, yPos, size, colors[row % colors.length], health, points, speed, shootRate));
                }
            }
            updateServer('wave-start');
            if (wave > 3) drawWaveMessage();
        }
        
        function drawWaveMessage() { /* Same as before */ }
        
        function checkCollisions() {
            const bulletsToRemove = new Set();
            const enemyBulletsToRemove = new Set();
            for (let i = 0; i < bullets.length; i++) {
                if (bulletsToRemove.has(i)) continue;
                const bullet = bullets[i];
                let bulletHit = false;
                for (let j = 0; j < enemies.length; j++) {
                    const enemy = enemies[j];
                    if (enemy.sinking) continue;
                    if (
                        bullet.x < enemy.x + enemy.width &&
                        bullet.x + bullet.width > enemy.x &&
                        bullet.y < enemy.y + enemy.height &&
                        bullet.y + bullet.height > enemy.y
                    ) {
                        bulletsToRemove.add(i);
                        bulletHit = true;
                        explosions.push(new Explosion(bullet.x + bullet.width / 2, bullet.y, '#ffffff'));
                        const destroyed = enemy.hit();
                        if (destroyed) {
                            explosions.push(new Explosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, enemy.color));
                        }
                        break;
                    }
                }
            }
            if (!player.invulnerable) {
                for (let i = 0; i < enemyBullets.length; i++) {
                    const bullet = enemyBullets[i];
                    if (
                        bullet.x < player.x + player.width &&
                        bullet.x + bullet.width > player.x &&
                        bullet.y < player.y + player.height &&
                        bullet.y + bullet.height > player.y
                    ) {
                        enemyBulletsToRemove.add(i);
                        explosions.push(new Explosion(bullet.x + bullet.width / 2, bullet.y + bullet.height / 2, '#ff0000'));
                        player.hit();
                    }
                }
            }
            const bulletIndices = Array.from(bulletsToRemove).sort((a, b) => b - a);
            for (const idx of bulletIndices) bullets.splice(idx, 1);
            const enemyBulletIndices = Array.from(enemyBulletsToRemove).sort((a, b) => b - a);
            for (const idx of enemyBulletIndices) enemyBullets.splice(idx, 1);
        }
        
        function updateGameObjects() {
            player.update();
            const bulletsToRemove = [];
            const enemiesToRemove = [];
            const enemyBulletsToRemove = [];
            const explosionsToRemove = [];
            for (let i = 0; i < bullets.length; i++) {
                bullets[i].update();
                if (bullets[i].y < 0) bulletsToRemove.push(i);
            }
            let gameOverTriggered = false;
            for (let i = 0; i < enemies.length; i++) {
                const alive = enemies[i].update();
                if (!alive) enemiesToRemove.push(i);
                if (!enemies[i].sinking && enemies[i].y + enemies[i].height > player.y) gameOverTriggered = true;
            }
            if (gameOverTriggered) {
                gameOver();
                return;
            }
            for (let i = 0; i < enemyBullets.length; i++) {
                enemyBullets[i].update();
                if (enemyBullets[i].y > canvas.height) enemyBulletsToRemove.push(i);
            }
            for (let i = 0; i < explosions.length; i++) {
                const alive = explosions[i].update();
                if (!alive) explosionsToRemove.push(i);
            }
            for (let i = bulletsToRemove.length - 1; i >= 0; i--) bullets.splice(bulletsToRemove[i], 1);
            for (let i = enemiesToRemove.length - 1; i >= 0; i--) enemies.splice(enemiesToRemove[i], 1);
            for (let i = enemyBulletsToRemove.length - 1; i >= 0; i--) enemyBullets.splice(enemyBulletsToRemove[i], 1);
            for (let i = explosionsToRemove.length - 1; i >= 0; i--) explosions.splice(explosionsToRemove[i], 1);
            if (enemies.length === 0) {
                wave++;
                let waveBonus = wave <= 3 ? 50 * wave : wave <= 5 ? 100 * wave : 200 * wave;
                score += waveBonus;
                scoreDisplay.textContent = `Score: ${score}`;
                createEnemies();
            }
            if (Date.now() - lastUpdateTime > 5000) {
                updateServer('heartbeat');
                lastUpdateTime = Date.now();
            }
        }
        
        function drawGameObjects() { /* Same as before */ }
        function drawStars() { /* Same as before */ }
        
        async function updateServer(eventType) {
            try {
                await fetch('/update-game', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': gameToken },
                    body: JSON.stringify({ sessionId, eventType, wave, score, lives, moveCount })
                });
            } catch (error) {
                console.error('Server update failed:', error);
            }
        }
        
        function gameLoop(timestamp) {
            if (!gameActive) return;
            if (!lastTime) lastTime = timestamp;
            const deltaTime = (timestamp - lastTime) / 1000;
            lastTime = timestamp;
            if (!gamePaused) {
                updateGameObjects();
                checkCollisions();
                if (Date.now() - lastMoveTime > 5000 && moveCount < 10) {
                    gameOver();
                    alert("Inactivity detected, game ended!");
                }
            }
            drawGameObjects();
            animationId = requestAnimationFrame(gameLoop);
        }
        
        async function startGame() {
            score = 0;
            lives = 3;
            wave = 1;
            bullets = [];
            enemyBullets = [];
            explosions = [];
            lastTime = 0;
            moveCount = 0;
            lastMoveTime = Date.now();
            lastUpdateTime = Date.now();
            player = new Player();
            createEnemies();
            scoreDisplay.textContent = `Score: ${score}`;
            waveDisplay.textContent = `Wave: ${wave}/${FINAL_WAVE}`;
            livesDisplay.textContent = `Lives: ${lives}`;
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            victoryScreen.style.display = 'none';
            if (isTouchDevice) mobileControls.style.display = 'flex';
            gameActive = true;
            gamePaused = false;
            requestAnimationFrame(gameLoop);
        }
        
        async function gameOver() {
            gameActive = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            finalScoreDisplay.textContent = `Your score: ${score}`;
            const reward = wave >= 3 && wave <= 4 ? 0.0025 : wave >= 5 && wave <= 9 ? 0.005 : 0;
            rewardMessage.textContent = reward > 0 ? `You earned ${reward} SOL for reaching wave ${wave}!` : 'Reach wave 3+ to earn SOL!';
            gameOverScreen.style.display = 'flex';
            victoryScreen.style.display = 'none';
            mobileControls.style.display = 'none';
            if (reward > 0) await updateServer('game-over');
        }
        
        async function victory() {
            gameActive = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            victoryScoreDisplay.textContent = `Final Score: ${score}`;
            victoryRewardMessage.textContent = 'You earned 0.01 SOL for defeating all waves!';
            victoryScreen.style.display = 'flex';
            gameOverScreen.style.display = 'none';
            mobileControls.style.display = 'none';
            createConfetti();
            await updateServer('victory');
        }
        
        function createConfetti() { /* Same as before */ }
        function togglePause() { /* Same as before */ }

        submitAddressButton.addEventListener('click', async () => {
            const address = solAddressInput.value.trim();
            const captchaResponse = hcaptcha.getResponse();
            faucetError.style.display = 'none';

            if (!address || address.length !== 44 || !/^[1-9A-HJ-NP-Za-km-z]+$/.test(address)) {
                faucetError.textContent = 'Invalid Solana address!';
                faucetError.style.display = 'block';
                return;
            }

            try {
                const response = await fetch('/start-game', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ address, captchaResponse })
                });
                const result = await response.json();
                if (!result.success) {
                    faucetError.textContent = result.error;
                    faucetError.style.display = 'block';
                    hcaptcha.reset();
                    return;
                }
                playerAddress = address;
                gameToken = result.token;
                sessionId = result.sessionId;
                faucetScreen.style.display = 'none';
                startScreen.style.display = 'flex';
            } catch (error) {
                faucetError.textContent = 'Server error, try again later!';
                faucetError.style.display = 'block';
            }
        });

        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', () => {
            faucetScreen.style.display = 'flex';
            gameOverScreen.style.display = 'none';
            hcaptcha.reset();
        });
        victoryRestartButton.addEventListener('click', () => {
            faucetScreen.style.display = 'flex';
            victoryScreen.style.display = 'none';
            hcaptcha.reset();
        });
        pauseButton.addEventListener('click', togglePause);

        window.addEventListener('keydown', (e) => {
            if (e.code in keys) {
                keys[e.code] = true;
                e.preventDefault();
            }
            if (e.code === 'Escape') togglePause();
        });
        
        window.addEventListener('keyup', (e) => {
            if (e.code in keys) keys[e.code] = false;
        });
        
        if (isTouchDevice) {
            leftButton.addEventListener('touchstart', () => { keys.ArrowLeft = true; });
            leftButton.addEventListener('touchend', () => { keys.ArrowLeft = false; });
            rightButton.addEventListener('touchstart', () => { keys.ArrowRight = true; });
            rightButton.addEventListener('touchend', () => { keys.ArrowRight = false; });
            fireButton.addEventListener('touchstart', () => { keys.Space = true; });
            fireButton.addEventListener('touchend', () => { keys.Space = false; });
        }
        
        window.addEventListener('blur', () => {
            if (gameActive && !gamePaused) togglePause();
        });
    </script>
</body>
</html>
